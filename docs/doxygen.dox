/**
@mainpage

<a href="https://github.com/ros-industrial/noether">Noether</a> provides software for performing tool path planning on
arbitrary mesh surfaces. See the following pages for more information on using Noether.

<ul>
  <li> @subpage page_concepts </li>
  <li> @subpage page_getting_started </li>
  <li> @subpage page_additional_resources </li>
</ul>

*/

// Define groups
/**
  @defgroup types Types
  @{
    @brief Common data types used for tool path planning
  @}
  @defgroup mesh_modifiers Mesh Modifiers
  @{
    @brief Implementations of the noether::MeshModifier interface
    @defgroup gui_widgets_mesh_modifiers Mesh Modifier Widgets
    @{
      @brief Instantiations of the noether::BaseWidget interface for mesh modifiers
    @}
  @}
  @defgroup tool_path_planners Tool Path Planners
  @{
    @brief Implementations of the noether::ToolPathPlanner interface

    @defgroup raster_planners Raster Planners
    @{
      @brief Implementations of the noether::RasterPlanner interface and associated components

      @details A noether::RasterPlanner is a subclass of noether::ToolPathPlanner with the following general properties:

      - Generally >1 raster
      - Generally covers the whole supplied surface
      - Lines are parallel
      - Repeating pattern of lines
      - All points lie on surface
      - All points have same orientation
      - noether::ToolPathWaypoint in rasters are consistently and spatially ordered
      - noether::ToolPathSegment are consistently and spatially ordered in noether::ToolPath
      - noether::ToolPaths are in order in top-level structure

      The organization of tool path waypoints, segments, and paths in the output of a raster planner is shown the following diagram:

      @image html static/raster_path.png

      The noether::RasterPlanner interface uses two additional interfaces to generate the location and direction of the raster lines.
      @ref origin_generators are used to specify the location of the first raster line on the mesh.
      @ref direction_generators are used to specify the direction of travel of the raster lines in the tool path.

      @defgroup direction_generators Direction Generators
      @{
        @brief Implementations of the noether::DirectionGenerator interface
        @details Given a mesh, this interface defines a 3D direction vector with which raster lines should be parallel.
      @}

      @defgroup origin_generators Origin Generators
      @{
        @brief Implementations of the noether::OriginGenerator interface
        @details Given a mesh, this interface defines a 3D position through which the first raster line should pass.
      @}
    @}

    @defgroup edge_planners Edge Planners
    @{
      @brief Implementations of the noether::EdgePlanner interface

      @details An noether::EdgePlanner is a subclass of noether::ToolPathPlanner with the following general properties:

      - A list of closed-loop edges around parts
      - noether::ToolPathSegment in sequential order in noether::ToolPath
      - noether::ToolPaths ordered by length of closed loop, with longest first
      - All loops start near some point (e.g. all in top left corner)
      - All loops process in same direction

      The organization of tool path waypoints, segments, and paths in the output of an edge planner is shown in the following diagram:

      @image html static/edge_path.png
    @}

    @defgroup gui_widgets_tool_path_planners Tool Path Planner Widgets
    @{
      @brief Instantiations of the BaseWidget interface for tool path planners
    @}
  @}
  @defgroup tool_path_modifiers Tool Path Modifiers
  @{
    @brief Implementations of the noether::ToolPathModifier interface

    @defgroup gui_widgets_tool_path_modifiers Tool Path Modifier Widgets
    @{
      @brief Instantiations of the BaseWidget interfaces for tool path modifiers
    @}
  @}
  @defgroup plugins Plugins
  @{
    Noether provides a plugin interface (noether::Plugin) for users to provide custom implementations of the tool path planning and GUI interfaces.

    To create a plugin, users need to do the following:
    - At build-time:
      - Create a library with an implementation of the desired tool path planning component(s)
      - Implement the noether::Plugin class for the tool path planning component
      - Export the *plugin* class(es) using the appropriate `EXPORT_<COMPONENT>_PLUGIN` macro(s)
    - At run-time:
      - Add the name of the library in which the plugin is defined to the `NOETHER_PLUGIN_LIBS` environment variable

    @section s_plugin_interface Plugin Interface

    noether::Plugin is the plugin class that gets loaded at run-time and is responsible for generating instances of a specific tool path planning component.
    This class needs to be overridden and its `create` method implemented for each custom tool path planning component.
    In this interface, the user is given configuration data (in the form of a `YAML::Node`) and an instance of the noether::Factory (e.g., for loading nested plugins).
    The user is expected to use this information to produce a configured instance of their custom tool path planning component.

    @subsection ss_plugin_simple Simplified Plugin Definition and Export

    The example below shows the definition and export of a plugin for noether::BoundaryEdgePlanner.
    This particular tool path planner can be fully configured using just the `YAML::Node` input, so we can create and export a plugin for it using the simplified `EXPORT_SIMPLE_<COMPONENT>_PLUGIN` macro.
    This macro takes as input the name of the tool path planning component class and an arbitrary alias by which we wish to refer to it (e.g., for loading from YAML files, etc.).
    Under the hood, this macro defines a plugin class using noether::SimplePlugin and exports it using the `EXPORT_<COMPONENT>_PLUGIN` macro.

    @snippet noether_tpp/src/plugins.cpp Plugins Example Simple

    The following macros can be used to define and export simple plugins for tool path planning components:

    - @ref EXPORT_SIMPLE_TOOL_PATH_PLANNER_PLUGIN
    - @ref EXPORT_SIMPLE_DIRECTION_GENERATOR_PLUGIN
    - @ref EXPORT_SIMPLE_ORIGIN_GENERATOR_PLUGIN
    - @ref EXPORT_SIMPLE_TOOL_PATH_MODIFIER_PLUGIN
    - @ref EXPORT_SIMPLE_MESH_MODIFIER_PLUGIN

    @subsection ss_plugin_complex Full Plugin Definition and Export

    The example below shows the definition and export of noether::CompoundModifier, a tool path modifier which requires more information than just the `YAML::Node` to be configured.
    In this case, we must fully define the plugin class and export it with the appropriate `EXPORT_<COMPONENT>_PLUGIN` macro:

    @snippet noether_tpp/src/plugins.cpp Plugins Example Complex

    The following macros can be used to export tool path planning component plugins:

    - @ref EXPORT_TOOL_PATH_PLANNER_PLUGIN
    - @ref EXPORT_DIRECTION_GENERATOR_PLUGIN
    - @ref EXPORT_ORIGIN_GENERATOR_PLUGIN
    - @ref EXPORT_TOOL_PATH_MODIFIER_PLUGIN
    - @ref EXPORT_MESH_MODIFIER_PLUGIN

    @section s_factory Plugin Factory

    The noether::Factory class is intended to be used to load plugins for tool path planning components.
    This class wraps the underlying plugin loader class and ensures that loaded plugin libraries stay in scope as long as the plugins (and objects create from them) are used.
    By default, noether::Factory is configured to know about plugin libraries from this repository, to look for plugin library names in the `NOETHER_PLUGIN_LIBS` environment variable, and to look for install paths of plugin libraries in the `NOETHER_PLUGIN_PATHS` envrionment variable.

    @note
    If the install path of the plugin library can be found in `LD_LIBRARY_PATH`, there is no need to set the `NOETHER_PLUGIN_PATHS` environment variable.
    For example, if this project is built in a ROS/ROS2 workspace, sourcing the workspace automatically adds its library paths to `LD_LIBRARY_PATH`.
  @}
  @defgroup gui_interfaces GUI Interfaces
  @{
    The GUI module is a `Qt`-based framework that allows customizable UI widgets to configure a tool path planning pipeline.
    At run-time, the GUI searches for plugins that provide these widgets, uses the plugins to populate the GUI, and then allows the end user to interactively create custom tool path plans.
    This plugin-based GUI architecture allows end-users to leverage the out-of-the-box GUI infrastructure and plugins, while still enabling private development of custom capabilities or customizations to the front-end of existing classes.

    To add a custom UI element to the GUI, users need to do the following:
    - At build-time:
      - Create a library with a Qt widget (inheriting from noether::BaseWidget) that produces the YAML configuration for a given tool path planning component
      - Implement the noether::WidgetPlugin class for the widget
      - Export the *plugin* class(es) using the appropriate `EXPORT_<COMPONENT>_WIDGET_PLUGIN` macro(s)
    - At run-time:
      - Add the name of the library in which the plugin is defined to the `NOETHER_PLUGIN_LIBS` environment variable.

    @section s_gui_widgets Widgets

    At the lowest level, the widgets in the GUI are used to produce the YAML configuration needed to load tool path planning components via plugin (see @ref plugins for more details about the tool path planning component plugins).
    noether::BaseWidget is the base class for these customizable widgets used in the GUI.

    Each implementation of a tool path planning component (e.g., mesh modifier, tool path planner, tool path modifier) must provide a widget that inherits noether::BaseWidget and is capable of configuring it.
    The widget should override the `save` method which translates the GUI elements (e.g., spin boxes, etc.) into the YAML configuration for the tool path planning component plugin.
    The widget should also override the `configure` method which sets the value of the GUI elements given the YAML configuration for the tool path planning component.

    @section s_gui_plugin_interface Widget Plugins

    To allow users to develop their own private implementations of tool path planning components and have them appear in the GUI, all widgets are loaded into the GUI application at runtime via plugin.
    This plugin class is defined in the noether::WidgetPlugin class.

    The GUI itself finds available widget plugins (via the `NOETHER_PLUGIN_LIBS` environment variable), loads them, and uses them to produce widgets to populate the various pages of the GUI.
    Just as each of the tool path planning component has a corresponding noether::BaseWidget to configure it, each noether::BaseWidget should also have a corresponding noether::WidgetPlugin that produces the noether::BaseWidget to allow it to be loaded into the GUI.

    @subsection ss_gui_plugin_simple Simplified Widget Plugin Definition and Export

    The example below shows the definition and export of a widget plugin for noether::BoundaryEdgePlannerWidget.
    This particular tool path planner widget can be fully configured using just the `YAML::Node` input, so we can create and export a plugin for it using the simplified `EXPORT_SIMPLE_<COMPONENT>_WIDGET_PLUGIN` macro.
    This macro takes as input the name of the tool path planning component widget class and an arbitrary alias by which we wish to refer to it (e.g., for loading from YAML files, etc.).
    Under the hood, this macro defines a plugin class using noether::SimpleWidgetPlugin and exports it using the `EXPORT_<COMPONENT>_WIDGET_PLUGIN` macro.

    @snippet noether_gui/src/plugins.cpp GUI Plugins Example Simple

    The following macros can be used to define and export simple plugins for tool path planning components:

    - @ref EXPORT_SIMPLE_TOOL_PATH_PLANNER_WIDGET_PLUGIN
    - @ref EXPORT_SIMPLE_DIRECTION_GENERATOR_WIDGET_PLUGIN
    - @ref EXPORT_SIMPLE_ORIGIN_GENERATOR_WIDGET_PLUGIN
    - @ref EXPORT_SIMPLE_TOOL_PATH_MODIFIER_WIDGET_PLUGIN
    - @ref EXPORT_SIMPLE_MESH_MODIFIER_WIDGET_PLUGIN

    @subsection ss_gui_plugin_complex Full Widget Plugin Definition and Export

    The example below shows the definition and export of noether::PlaneSlicerRasterPlannerWidget, a tool path planner widget which requires more information than just the `YAML::Node` to be configured.
    In this case, we must fully define the plugin class and export it with the appropriate `EXPORT_<COMPONENT>_WIDGET_PLUGIN` macro:

    @snippet noether_gui/src/plugins.cpp GUI Plugins Example Complex

    The following macros can be used to export tool path planning component plugins:

    - @ref EXPORT_TOOL_PATH_PLANNER_WIDGET_PLUGIN
    - @ref EXPORT_DIRECTION_GENERATOR_WIDGET_PLUGIN
    - @ref EXPORT_ORIGIN_GENERATOR_WIDGET_PLUGIN
    - @ref EXPORT_TOOL_PATH_MODIFIER_WIDGET_PLUGIN
    - @ref EXPORT_MESH_MODIFIER_WIDGET_PLUGIN

    @subsection ss_configuration_file Shared YAML Configuration File

    The same YAML configuration file can and should be used to load both tool path planning component plugins and GUI widget plugins.
    In order to accomplish this, the alias of the widget plugin should be the same as the alias for the tool path planning component plugin that it configures.

    For example, the noether::PlaneProjectionMeshModifier and the noether::PlaneProjectionMeshModifierWidget plugin classes are exported with the same alias: `PlaneProjection`.

    @snippet noether_tpp/src/plugins.cpp Plugin Alias Correspondence
    @snippet noether_gui/src/plugins.cpp GUI Plugin Alias Correspondence

    However, in some cases there is not a direct correspondence between a widget and the tool path planning component(s) it configures.
    For cases like this, the plugins can have different aliases, and a separate entry in the YAML configuration (`gui_plugin_name`) is used to specify the GUI plugin name.

    For example, noether::CrossHatchPlaneSlicerRasterPlannerWidget is a widget that configures a noether::MultiToolPathPlanner in a specific way to produce a cross-hatch tool path planner.
    In this case, the plugin for noether::CrossHatchPlaneSlicerRasterPlannerWidget has the alias `CrossHatchPlaneSlicer`, and the plugin for noether::MultiToolPathPlanner has the alias `Multi`.
    The corresponding YAML configuration for this cross-hatch tool path planner is shown below:

    @code{.yaml}
    tool_path_planner:
      name: Multi                             # Name of the tool path planning component plugin
      gui_plugin_name: CrossHatchPlaneSlicer  # Name of the widget plugin
      planners:                               # Remainder of the configuration
        - ...
        - ...
    @endcode

    @section s_gui_factory Widget Plugin Factory

    The noether::WidgetFactory class is intended to be used to load plugins for tool path planning component widgets.
    This class wraps the underlying plugin loader class and ensures that loaded plugin libraries stay in scope as long as the plugins (and objects create from them) are used.
    By default, noether::WidgetFactory is configured to know about widget plugin libraries from this repository, to look for plugin library names in the `NOETHER_PLUGIN_LIBS` environment variable, and to look for install paths of plugin libraries in the `NOETHER_PLUGIN_PATHS` envrionment variable.

    @note
    If the install path of the plugin library can be found in `LD_LIBRARY_PATH`, there is no need to set the `NOETHER_PLUGIN_PATHS` environment variable.
    For example, if this project is built in a ROS/ROS2 workspace, sourcing the workspace automatically adds its library paths to `LD_LIBRARY_PATH`.

    @section s_gui_architecture Architecture

    The image below shows the architecture of the GUI components described in the previous sections.

    @image html static/architecture_gui.png
  @}
  @defgroup mesh_primitive_generation Mesh Generation for Shape Primitives
  @{
    @brief Functions for generating meshes for various types of shape primitives
  @}
*/
